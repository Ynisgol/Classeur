<h1 id="fenwick-tree-binary-indexed-tree">Fenwick Tree (Binary Indexed Tree)</h1>
<p>Fenwick Tree is a tree-structured array that can be used for frequency calculation. Given an array <script type="math/tex; mode=display" id="MathJax-Element-4910">a = [a_0, a_1, ..., a_{n-1}]</script>, whose element value set is <script type="math/tex; mode=display" id="MathJax-Element-4911">s = \{s_1, s_2, ..., s_m\}</script> assuming <script type="math/tex" id="MathJax-Element-4912">s_k (1\le k\le m)</script> is in sorted order. We donâ€™t really care about the actual value of <script type="math/tex" id="MathJax-Element-4913">s_k</script>. We only want to know how many times the <script type="math/tex" id="MathJax-Element-4914">k</script>th element occurs. We call the counts array <script type="math/tex" id="MathJax-Element-4915">c</script> so that <script type="math/tex" id="MathJax-Element-4916">c[k]</script> means the count of the <script type="math/tex" id="MathJax-Element-4917">k</script>th element. So, a Fenwick Tree is defined as an array of size <script type="math/tex" id="MathJax-Element-4918">m</script> named <script type="math/tex" id="MathJax-Element-4919">f</script>. For each <script type="math/tex" id="MathJax-Element-4920">k</script>, if, in its binary representation, the least significant bit that is <script type="math/tex" id="MathJax-Element-4921">1</script> is representing <script type="math/tex" id="MathJax-Element-4922">2^p</script>, then <script type="math/tex; mode=display" id="MathJax-Element-4923">f[k] = \sum_{l = 1}^{2^p}c[k - 2^p + l]</script>. So, when <script type="math/tex" id="MathJax-Element-4924">c[k]</script> changes, <script type="math/tex" id="MathJax-Element-4925">\forall k'</script> so that <script type="math/tex" id="MathJax-Element-4926">k' - 2^{p'} + 1 \le k\le k' \le m</script>, <script type="math/tex" id="MathJax-Element-4927">f[k']</script> needs to be updated.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">class</span> FenwickTree<span class="token punctuation">:</span>
	<span class="token keyword">def</span> __init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>m <span class="token operator">=</span> m
        self<span class="token punctuation">.</span>fArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> 

	<span class="token keyword">def</span> update<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> k <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>m<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>fArray<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>
            k <span class="token operator">+</span><span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token operator">-</span>k
        <span class="token keyword">return</span>
</code></pre>
